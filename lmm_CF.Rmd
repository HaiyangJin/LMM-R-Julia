---
title: "Generalized linear mixed-effects modeling of the composite face task"
author: "[Haiyang Jin](https://haiyangjin.github.io/)"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_float: true
---

```{r global_options, echo = FALSE, include = FALSE}
options(width = 2000)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, include = TRUE,
                      cache = FALSE, tidy = FALSE, size = "small")
```

# Preparation
```{r setup and load the related libraries, include=FALSE}
library(tidyverse)
library(hypr)
# library(MASS)
library(lme4)
library(lmerTest)
library(optimx)
library(emmeans)
```

## Prepare data
```{r read the data file}
# backup codes
# df_tmp <- read_csv(file.path("data", "example.csv")) %>%
#   transmute(Participant = as_factor(Participant),
#             Condition = if_else(substr(Experiment,1,3)=="104", "CFS", "monocular"),
#             Congruency = if_else(Congruency=="C", "congruent", "incongruent"),
#             Alignment = if_else(Alignment=="A", "aligned", "misaligned"),
#             answer = if_else(SameDifferent=="S", "same", "different"),
#             resp = if_else(thisResponse=="S", 1, 0),
#             isCorrect = isCorrect,
#             RT = round(reactionTime*1000+200)) %>%
#   mutate(Participant = sprintf("Subj%02d", as.numeric(Participant)))
# write_csv(df_tmp, file = file.path("data", "example_data.csv"))

folder_out <- "output"

# levels for the new factor (see below)
list_var <- c("OCAS", "OCAD", "OIAS", "OIAD", "OCMS", "OCMD", "OIMS", "OIMD", "FCAS", "FCAD", "FIAS", "FIAD", "FCMS", "FCMD", "FIMS", "FIMD")

df_raw <-  read_csv(file.path("data", "example_data.csv")) %>% 
  mutate(I_ = paste0(if_else(Condition == "monocular", "O", "F"), 
                     if_else(Congruency == "congruent", "C", "I"),
                     if_else(Alignment == "alignment", "A", "M"),
                     if_else(answer == "same", "S", "D")),
         I_ = factor(I_, levels=list_var))
head(df_raw)
```

## Brief introduction
This data was a subset of [one previous study](https://psyarxiv.com/j8g6z/). The independent variables are:
+ Condition: monocular (**O**) vs. CFS (**F**)
+ Congruency: congruent (**C**) vs. incongruent (**I**)
+ Alignment: aligned (**A**) vs. misaligned (**M**)
+ answer: same (**S**) vs. different (**D**) (regarded as `signal` and `noise` in Signal Detection Theory)

The dependent variables are behavioral responses and response times. Behavioral responses will be analyzed with signal detection theory (i.e., generalized linear mixed-effects models with probit link). Response times will be analyzed with lognormal transformation.

The main research questions are: 
(1) whether there is composite face effect in the `CFS` condition;
(2) whether there is composite face effect in the `monocular` condition;
(3) whether the composite face effect is larger in the `monocular` relative to the `CFS` condition. 

As discussed [earlier](https://psyarxiv.com/yhmzg/), we may claim observing the composite face effect in a particular condition (e.g., `CFS` or `monocular`) only when (1) the performance for aligned faces is better in the congruent relative to the incongruent condition (i.e., `congruent_aligned` > `incongruent_aligned`; `CA` > `IA`) and (2) the increased performance in congruent relative to incongruent condition is larger for aligned compared to misaligned faces (i.e., (`congruent_aligned` - `incongruent_aligned`) > (`congruent_misaligned` - `incongruent_misaligned`); (`CA` - `IA`) > (`CM` - `IM`)). 

Moreover, for the third question, we also need to examine whether the composite effect in the `monocular` condition is larger than that in the `CFS` condition (i.e., [(`monocular_congruent_aligned` - `monocular_incongruent_aligned`) - (`monocular_congruent_misaligned` - `monocular_incongruent_misaligned`)] > [(`CFS_congruent_aligned` - `CFS_incongruent_aligned`) - (`CFS_congruent_misaligned` - `CFS_incongruent_misaligned`)]; [(`OCA` - `OIA`) - (`OCM` - `OIM`)] > (`FCA` - `FIA`) - (`FCM` - `FIM`)]). 


# GLMM with probit link
sensitivity d'

## Priori contrasts

```{r}
hypr_resp <- hypr(OCAS - OCAD - OIAS + OIAD ~ 0,
                  OCAS - OCAD - OIAS + OIAD - OCMS + OCMD + OIMS - OIMD ~ 0,
                  FCAS - FCAD - FIAS + FIAD ~ 0,
                  FCAS - FCAD - FIAS + FIAD - FCMS + FCMD + FIMS - FIMD ~ 0,
                  # OCAS - OCAD - OIAS + OIAD - OCMS + OCMD + OIMS - OIMD - (FCAS - FCAD - FIAS + FIAD - FCMS + FCMD + FIMS - FIMD) ~ 0,
                  levels = list_var
)
hypr_resp
```

```{r}
contrasts(df_raw$I_) <- contr.hypothesis(hypr_resp)
```



```{r}
hypo_resp <- matrix(c(+1, -1, -1, +1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # con vs. incon ali monocular {1}
                      # +1, -1, -1, +1, -1, +1, +1, -1,  0,  0,  0,  0,  0,  0,  0,  0, # con vs. incon; ali vs. mis; monocular {1}
                       0,  0,  0,  0,  0,  0,  0,  0, +1, -1, -1, +1,  0,  0,  0,  0, # con vs. incon ali CFS
                       # 0,  0,  0,  0,  0,  0,  0,  0, +1, -1, -1, +1, -1, +1, +1, -1, # con vs. incon; ali vs. mis; CFS {1}
                      +1, -1, -1, +1, -1, +1, +1, -1, -1, +1, +1, -1, +1, -1, -1, +1, # con vs. incon; ali vs. mis; monocular vs. CFS
                      
                      # +1, -1, -1, +1,  0,  0,  0,  0, -1, +1, +1, -1,  0,  0,  0,  0, # complementary {1}
                      # +1, -1,  0,  0,  0,  0,  0,  0, -1, +1,  0,  0,  0,  0,  0,  0, # complementary {1}
                      # +1,  0, -1,  0,  0,  0,  0,  0, -1,  0, +1,  0,  0,  0,  0,  0, # complementary {1}
                      # +1,  0,  0,  0,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                      # +1,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                      # +1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                      # +1,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                      #  0,  0,  0,  0,  0,  0,  0,  0, +1,  0,  0,  0, -1,  0,  0,  0, # complementary {1}
                      # +1,  0, -1,  0, -1,  0, +1,  0,  0,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                      #  0,  0,  0,  0,  0,  0,  0,  0, +1,  0, -1,  0, -1,  0, +1,  0, # complementary {1}
                      # +1, -1,  0,  0, -1, +1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # complementary {1}
                       0,  0,  0,  0,  0,  0,  0,  0, +1, -1,  0,  0, -1, +1,  0,  0  # complementary {1}
                    ), nrow = 16)

con_resp <- MASS::fractions(t(ginv(hypo_resp)))
rownames(con_resp) <- list_var
# colnames(con_resp) <- c("Con_A_O", "CF_O", "Con_A_F", "CF_F", "CF_OF", sprintf('e%d', 6:15))

con_resp
```

**Question**: According to my research question, I need to test the five effects discussed earlier (i.e., the first five columns in `hypr_resp`). How should I decide the other (10) effects tested in the model?

```{r}
# apply the custom contrast to raw data
contrasts(df_raw$I_) <- con_resp

# create variables for each parameter
df_resp <- as_tibble(model.matrix(~ 1 + I_, df_raw)) %>% 
  cbind(df_raw, .)
```


## The maximal model
```{r resp max d }
# file_resp_max <- file.path(folder_out, "Resp_lmm_max.RData")
# 
# # fit the max model
# if (!file.exists(file_resp_max)) {
#   glmm_resp_max <- glmer(resp ~ I_ + 
#                            (I_Con_A_O + I_CF_O + I_Con_A_F + I_CF_F + I_CF_OF + 
#                               I_e6 + I_e7 + I_e8 + I_e9 + I_0 + I_1 + I_2 + 
#                               I_3 + I_4 + I_5 | Participant), 
#     family = binomial(link = "probit"),
#     data = df_resp,
#     control = glmerControl(optimizer = "optimx", # calc.derivs = FALSE,
#                            optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
#   )
# 
#   save(glmm_resp_max, file = file_resp_max)
# } else {
#   load(file_resp_max)
# }
# 
# print(summary(glmm_resp_max), corr = FALSE)
```

## The zero-correlation-parameter model
```{r resp zcp }

glmm_resp_zcp <- glmer(resp ~ Condition * Congruency * Alignment * answer + 
                           (I_Con_A_O + I_CF_O + I_Con_A_F + I_CF_F + I_CF_OF + 
                              I_e6 + I_e7 + I_e8 + I_e9 + I_0 + I_1 + I_2 + 
                              I_3 + I_4 + I_5 || Participant), 
    family = binomial(link = "probit"),
    data = df_resp,
    control = glmerControl(optimizer = "optimx", # calc.derivs = FALSE,
                           optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )



file_resp_zcp <- file.path(folder_out, "Resp_lmm_zcp.RData")

# fit the zcp model
if (!file.exists(file_resp_zcp)) {
  glmm_resp_zcp <- glmer(resp ~ I_ + 
                           (I_ || Participant), 
    family = binomial(link = "probit"),
    data = df_resp,
    control = glmerControl(optimizer = "optimx", # calc.derivs = FALSE,
                           optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )

  save(glmm_resp_zcp, file = file_resp_zcp)
} else {
  load(file_resp_zcp)
}

print(summary(glmm_resp_zcp), corr = FALSE)

```

## The reduced model
```{r PCA analysis for resp zcp lmm }
summary(rePCA(glmm_resp_zcp))
```



## The extended model
```{r resp etd }

```

```{r}
summary(rePCA(glmm_resp_etd))
```


## The optimal model
```{r comapre etd and rdc  d}
# compare the extended and reduced model
anova(glmm_resp_etd5, glmm_resp_rdc, refit = FALSE)
```



```{r the optimal model  d}
glmm_resp_opt <- glmm_resp_rdc

print(summary(glmm_resp_opt), corr = FALSE)
```


# Lognormal
for response times
```{r only keep correct trials (but with both same and different trials) }
df_rt <- df_raw %>% 
  filter(isCorrect == 1)

```

## The maximal model
```{r  rt max}


```


## The zero-correlation-parameter model
```{r  rt zcp}
file_rt_zcp <- file.path(folder_lmm, "rt_lmm_zcp.RData")

# fit the zcp1 model
if (!file.exists(file_rt_zcp)) {
  glmm_rt_zcp <- lmer(
    # log(rt) ~ Cue * Congruency * Alignment +  
    #   (Cue_C + Con_C + Ali_C + 
    #      Cue_Con + Cue_Ali + Con_Ali + 
    #      Cue_Con_Ali || Participant),
    data = df_lmm,
    control = lmerControl(optimizer = "optimx", # calc.derivs = FALSE,
                          optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
  # save(glmm_rt_zcp, file = file_rt_zcp)
} else {
  load(file_rt_zcp)
}

print(summary(glmm_rt_zcp), corr = FALSE)
```

## The reduced model
```{r PCA analysis for rt zcp lmm }
summary(rePCA(glmm_rt_zcp))
```

`Con_Ali` was removed from extended model (`glmm_rt_zcp`) due to that the variance it explained was smaller than 0.1%, making `glmm_rt_rdc`.

```{r  rt rdc}
file_rt_rdc <- file.path(folder_lmm, "rt_lmm_rdc.RData")

# fit the rdc1 model
if (!file.exists(file_rt_rdc)) {
  glmm_rt_rdc <- lmer(
    log(RT) ~ Cue * Congruency * Alignment +  
      (Cue_C + Con_C + Ali_C + 
         Cue_Con + Cue_Ali + # Con_Ali + 
         Cue_Con_Ali || Participant),
    data = df_lmm_rt,
    control = lmerControl(optimizer = "optimx", # calc.derivs = FALSE,
                          optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
  # save(glmm_rt_rdc, file = file_rt_rdc)
} else {
  load(file_rt_rdc)
}

print(summary(glmm_rt_rdc), corr = FALSE)
```

## The extended model

## The optimal model
```{r  comapre rt etd and rdc}
# compare the extended and reduced model
anova(glmm_rt_etd1, glmm_rt_rdc, refit = FALSE)
```


```{r  the optimal model rt}
glmm_rt_opt <- glmm_rt_rdc

print(summary(glmm_rt_opt), corr = FALSE)
```

# Session information {.unlisted .unnumbered}
```{r}
sessionInfo()
```


